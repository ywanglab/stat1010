[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 1010 Lecture Notes",
    "section": "",
    "text": "Preface\nThis is a book for STAT 1010: Introduction to Data Science at Auburn University at Montgomery. The book is written using Quarto.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book for STAT 1010: Introduction to Data Science offered at Auburn University at Montgomery.\nThis an ongoing project and updates are perpetually added.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "python_comp_env.html#use-google-colab",
    "href": "python_comp_env.html#use-google-colab",
    "title": "2  Setting-up Python Computing Environment",
    "section": "2.1 Use Google Colab",
    "text": "2.1 Use Google Colab\nAll you need is a Google account. Sign in your Google account in a browser, and navigate to Google Colab. Google Colab supports both Python and R. Python is the default engine. Change the engine to R in Connect-&gt;change runtime type. Then you are all set. Your file will be saved to your Google Drive or you can choose to send it to your GitHub account (recommended).\n\n2.1.1 How to run a project file from your Google Drive?\nMany times, when you run a python file in Colab, it needs to access other files, such as data files in a subdirectory. In this case, it would be convenient to have the same file structure in the Google Colab user home directory. To do this, you can use Google Drive to store your project folder, and then mount the Google Drive in Colab.\nLet’s assume the project folder name, pydata-book/.Here are the steps:\n\ngit clone the project folder (example: git clone https://github.com/wesm/pydata-book.git) to your local folder. This step is only needed when you want to clone some remote repo from GitHub.\nUpload the folder (ex: pydata-book) to Google Drive.\nOpen the file using Colab. In Google Drive, double click on the ipynb file, example, ch06.ipynb (or click on the three dots on the right end, and choose open with, then Google Colaborotary), the file will be opened by Google Colab.\nMount the Google Drive. In Google Colab, with the specific file (example, ch06.ipynb) being opened, move your cursor to the first code cell, and then click on the folder icon (this should be the fourth icon) on the upper left border in the Colab browser. This will open the file explorer pane. Typically you would see a folder named sample_data shown. On the top of the pane, click on the Google Drive icon to mount the Google Drive. Google Colab will insert the following code below the cursor in your opened ipynb file:\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\nRun this code cell by pressing SHIFT+ENTER, and follow the prompts to complete the authentication. Wait for ~10 seconds, your Google Drive will be mounted in Colab, and it will be displayed as a folder named drive in the file explorer pane. You might need to click on the Refresh folder icon to see the folder drive.\n5. Open a new code cell below the above code cell, and type the code\n%cd /content/drive/MyDrive/pydata-book/\nThis is to change the directory to the project directory on the Google Drive. Run this code cell, and you are ready to run the file ch06.ipynb from the folder pydata-book on your personal Google Drive, just like it’s on your local computer.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setting-up Python Computing Environment</span>"
    ]
  },
  {
    "objectID": "python_comp_env.html#on-your-own-computer",
    "href": "python_comp_env.html#on-your-own-computer",
    "title": "2  Setting-up Python Computing Environment",
    "section": "2.2 On your own computer",
    "text": "2.2 On your own computer\n\nAnaconda: Download anaconda and install using default installation options\nVSC: Download VSC and install\nstart VSC and install VSC extensions in VSC: Python, Jupyter, intellicode\n(optional) Quarto for authoring: Download Quarto and install\nStart an anaconda terminal. Navigate to the file directory.\nSetup a conda virtual environment: stat1010 and install python and ipykernel engines\nconda create -n stat1010 python ipykernel\nActivate the venv: conda activate stat1010\nstart VSC by typing code . in the anaconda terminal.\nopen/create a .ipynb or .py file.\nSelect the kernel stat1010\nRun a code cell by pressing Shift+Enter or click the triangular play button.\nContinue to run other cells.\nAfter finishing using VSC, close the VSC, and deactivate the virtual environment in a conda terminal: conda deactivate",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setting-up Python Computing Environment</span>"
    ]
  },
  {
    "objectID": "r_comp_env.html#setting-up-your-own-computing-environment-on-a-personal-computer",
    "href": "r_comp_env.html#setting-up-your-own-computing-environment-on-a-personal-computer",
    "title": "3  Setting-up R Studio Computing Environment",
    "section": "3.1 Setting up your own computing environment on a personal computer",
    "text": "3.1 Setting up your own computing environment on a personal computer\nThis is the recommended way and the advantage is that it’s easy to handle files.\n\nGo to the website &lt;https://posit.co/download/rstudio-desktop/&gt;.\nFollow the two steps:\n\ndownload and install R: Choose the appropriate operating system, and then choose “base” to “install R for the first time”. You can simply accept all default options.\ndownload Rstudio Desktop and Install it.\n\n\nAfter installation, start R-Studio, and you are ready to use it.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Setting-up R Studio Computing Environment</span>"
    ]
  },
  {
    "objectID": "r_comp_env.html#use-r-studio-cloud-no-setting-up-needed",
    "href": "r_comp_env.html#use-r-studio-cloud-no-setting-up-needed",
    "title": "3  Setting-up R Studio Computing Environment",
    "section": "3.2 Use R-Studio Cloud (No setting-up needed)",
    "text": "3.2 Use R-Studio Cloud (No setting-up needed)\nAlternatively, one can save the hassle of setting up on a personal computer and use the R-Studio Cloud for free. Here are the steps:\n\nGo to the website https://login.rstudio.cloud.\nEither create a new account using an email address such as your AUM email or simply “Log in using Google” or click on other log-in alternative.\n\nAfter log-in to your account, you are ready to use R Studio.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Setting-up R Studio Computing Environment</span>"
    ]
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "4  Use Git and GitHub",
    "section": "",
    "text": "5 Concrete example: what does “merge C with D to produce M” look like?\nAssume the repo has one file, README.md.\nWhen you rebase local commits that were already pushed, your local branch history no longer matches the remote’s. A normal git push will be rejected. You need to overwrite the remote branch tip—i.e., a force push.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#download-git",
    "href": "git.html#download-git",
    "title": "4  Use Git and GitHub",
    "section": "4.1 Download Git",
    "text": "4.1 Download Git\n\nGo to the website https://git-scm.com/downloads, select an appropriate operating system, select “Click here to download”\nRun the downloaded setup file with a name such as Git-2.42.0.2-64-bit.exe, and accept all default options.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#establish-a-connection-between-a-local-repo-and-a-remote-github-repo",
    "href": "git.html#establish-a-connection-between-a-local-repo-and-a-remote-github-repo",
    "title": "4  Use Git and GitHub",
    "section": "4.2 Establish a connection between a local repo and a remote GitHub repo",
    "text": "4.2 Establish a connection between a local repo and a remote GitHub repo\n\n4.2.1 Clone an existing repo on GitHub\nThis is an easier way to establish a connection between a local repo and a remote repo if the remote repo is created ahead. We will make a connection between a remote repo in your GitHub account and a local directory. If the remote repo is not under your account, then skip steps 1 and 2.\n\nSign in to your GitHub account, and create a GitHub repo (such as named homework) on GitHub (https://github.com), you can add a README.md file or just choose not to add a README.md file.\nOn your local computer, open a Git Bash terminal.\nSkip this step if you simply want the cloned repo to be in the current directory. Otherwise, In the terminal, type mkdir myfolder (create a folder named myfolder within the current directory) and then cd myfolder (change to the directory myfolder). The directory name myfolder can be any name you want.\ngit clone https://github.com/Your_Git_UserName/homework.git (change the remote repo path to match your actual remote repo).\n\n\n\n\n\n\nNote\n\n\n\nTo specify a specific folder to clone to, add the name of the folder after the repository URL, like this: git clone github-repo-URL mylocalfolder\n\n\nNow you have established a connection between your local directory homework and the remote repo homework on GitHub.\nCreate a new file in the current local directory homewor on your local computer, such as using your favorite editor to create a file named myfirstlocalfile.txt with any content in it. Or for the sake of demonstration, you can use the following Linux command to create this file containing the line #My first local file.\necho \"#My first local file\" &gt;&gt; myfirstlocalfile.txt\nIn the terminal, git add . This will add all changes to the staging area. This lets Git start to track the changes to files in your local directory.\nNow you are ready to commit the changes, which versions (takes a snapshot of) the current files in the directory. A commit is a checkpoint where you can go back to.\ngit commit -m \"my first commit from local\"\nNow you are ready to sync the local repo with the remote repo.\ngit push\nThe GitHub might ask you to sign in for the first time. Choose Sign in with your brower to sign in to complete the push.\n\n\n\n4.2.2 Initializing a Git Directory Locally First\nThe previous approach initializes a local Git repo by cloning a remote repo. You can also initialize a local Git repo by using git init. Follow the following steps:\n\nSign in to your GitHub account.\nCreate a GitHub empty repo (such as named homework) on GitHub (https://github.com) but make sure it is empty (do not add Readme.md file)\nStart a Git Bash Terminal window on your local computer (You could also use the Terminal Window in RStudio or VSC). Navigate to the project directory; if you haven’t yet created a project directory such as homework, do\nmkdir project_dir Example: mkdir homework\nUse cd project_directory_name to enter your local project directory;\nUse ls to list all files and directories or use ls -al to include all hidden files and directories. In your local Git Terminal, (note at this moment your local project directory is empty)\necho \"# homework0\" &gt;&gt; README.md  #create a file README.md\ngit init\ngit branch -M main #rename the branch name to main\ngit add .  # may use git add --all\ngit commit -m \"first commit\"\ngit remote add origin https://github.com/ywanglab/homework.git #(change the remote repo path to your remote repo)\ngit push -u origin main # only need to do this first time. Afterwards, only `git push`\n\n\n\n\n\n\nNote\n\n\n\n\nthe general command format: git push [remote-name] [branch-name]\ndifference between git add . and git add --all:\ngit add .: stages changes in the current directory and its subdirectories but does not include file deletions\ngit add --all: stages changes in the entire working tree, including deletions and untracked files. It is a more aggressive option and can be useful when you want to ensure that every change, including file deletions, is included in the next commit.\ngit add --all is equivalent to git add -A\n\n\n\nif your local project directory already 1) contains files and 2) had performed init git before, then\ngit remote add origin https://github.com/ywanglab/homework.git` #(change the remote repo path to your remote repo path)\ngit branch -M main\ngit push -u origin main\nin the pop-out GitHub Sign-in window, click on Sign in with your browser.\nNote an empty folder would not be pushed to the remote repo until it has a file (even an empty file) in it. In this case, you can create an empty file such as .gitignore",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#some-other-common-commands",
    "href": "git.html#some-other-common-commands",
    "title": "4  Use Git and GitHub",
    "section": "4.3 Some other common commands",
    "text": "4.3 Some other common commands\n\ncheck git status: git status and git status --short for a compact way.\ngit commit -a -m \"message\" will stage and commit every changed, already tracked file without using git add changed_file\ngit add file_changed\n# add file_changed to the staging environment, i.e., git repo to start track those changes.\nuse git log to check all commits. Use git log --pretty=oneline or just git log --oneline for shorter display.\ngit log origin/main #check the remote repo origin/main commits\nuse git diff origin/main to show the differences between the local main and origin/main.\nuse git checkout . to revert back to the previous commit. Any changes after the previous commit will be abandoned.\nto get to a previous commit, use git checkout seven_character_commit_hash. To get back to main, use git checkout main.\nGit commit --amend\n\ncommit --amend is used to modify the most recent commit. It combines changes in the staging environment with the latest commit, and creates a new commit. This new commit replaces the latest commit entirely. Adding files with--amend works the same way as above. Just add them to the staging environment before committing.\nOne of the simplest things you can do with --amend is to change a commit message with spelling errors.\n\nGit Revert HEAD:\nrevert is the command we use when we want to take a previous commit and add it as a new commit, keeping the log intact. Revert the latest commit using git revert HEAD (revert the latest change, and then commit), adding the option --no-edit to skip the commit message editor (getting the default revert message):\ngit revert HEAD --no-edit\n\n\n\n\n\n\nNote\n\n\n\nTo revert to earlier commits, use git revert HEAD~x (x being a number. 1 going back one more, 2 going back two more, etc.)\n\n\nGit Reset\nreset is the command used when we want to move the repository back to a previous commit, discarding any changes made after that commit. Let’s try and do that with reset.\ngit reset seven-char-commit-hash\nGit Undo Reset\nEven though the commits are no longer showing up in the log, it is not removed from Git. If you know the commit hash you can reset to it:\ngit reset seven-char-commit-hash\nTo permanently go back to a previous commit, use\ngit reset --hard seven_char_commit_hash\nto go back to a previous commit, but not changing the files in the working directory use the --soft` option.\ngit reset --soft seven_char_commit_hash\ngit remote -v Get the reminder of the remote repo. To rename the remote origin: git remote rename origin upsteam rename remote repo origin to upstream\n\n\n\n\n\n\nNote\n\n\n\nAccording to Git naming conventions, it is recommended to name your own repository origin which you have read and write access; and the one you forked for upstream (which you only have read-only access.)\n\n\nif you want to remove the file only from the remote GitHub repository and not remove it from your local filesystem, use:\n\ngit rm -rf --cached file1.txt #This will only remote files; If intending to remove local files too, remove --cached\ngit commit -m \"remove file1.txt\" \nAnd then push changes to remote repo\ngit push origin main \n\nFor some operating system, such as Mac or Linux, you might be asked to tell GitHub who you are. When you are prompted, type the following two commands in your terminal window:\n\ngit config --global user.name \"Your Name\" \ngit config --global user.mail \"your@email.com\"\nThis will change the Git configuration in a way that anytime you use Git, it will know this information. Note that you need to use the email account that you used to open your GitHub account. global sets the username and e-mail for every repo on your computer. If you want to set the username/e-mail just for the current repo, remove global.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#use-git-help",
    "href": "git.html#use-git-help",
    "title": "4  Use Git and GitHub",
    "section": "4.4 Use Git help",
    "text": "4.4 Use Git help\n\ngit command -help See all the available options for the specific command. Use `--help instead of -help to open the relevant Git manual page.\ngit help --all See all possible commands",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#when-the-upstream-repo-changes",
    "href": "git.html#when-the-upstream-repo-changes",
    "title": "4  Use Git and GitHub",
    "section": "4.5 When the upstream repo changes",
    "text": "4.5 When the upstream repo changes\nWhen Git tells you the upstream repo is ahead,\n\nDo git pull or git pull origin\nThis is equivalent to git fetch origin, and then git merge origin/main.Then you can commit and push a new version to the remote repo.\ngit pull will not pull a new branches on the remote repo to local, but it will inform you if there is a new branch on the remote repo. In this case, just git checkout the_remote_new_branch_name will pull the remote branch to local. Note there is no need to create locally the branch by git branch the_remote_new_branch_name",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#create-branch",
    "href": "git.html#create-branch",
    "title": "4  Use Git and GitHub",
    "section": "4.6 Create branch",
    "text": "4.6 Create branch\n\nTo add a branch to the main branch git branch branchname\nSwitch the branch git checkout branchname\nTo combine the above two actions, git checkout -b branchname, create a new branch named branchname if it does not exist and move to it.\n\nAdding a file in branch echo \"#content\" &gt;&gt; filename.txt\nThen add the file and commit the file. To push the branch to the remote repo we have to use\ngit push --set-upstream origin branchname The option --set-upstream can be replaced by -u\nto see all branches in both local and remote: git branch -a Or git branch -r for remote only.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#merge-branch-to-main-branch",
    "href": "git.html#merge-branch-to-main-branch",
    "title": "4  Use Git and GitHub",
    "section": "4.7 Merge branch to main branch",
    "text": "4.7 Merge branch to main branch\n\nSwitch from a branch (with name such as branchname to the main using\ngit checkout main\non the main branch, Merge command to merge the branches\ngit merge branchname\n\nTo delete a branch:\ngit branch -d branchname",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#handle-large-files-150mb-on-github",
    "href": "git.html#handle-large-files-150mb-on-github",
    "title": "4  Use Git and GitHub",
    "section": "4.8 Handle large files (>= 150Mb) on GitHub",
    "text": "4.8 Handle large files (&gt;= 150Mb) on GitHub\nGitHub does not allow to upload a file of size greater than 150Mb. However, one can use git lfs to handle large files exceeding this size up to several Giga bytes. The first thing is to install git lfs. Head to https://git-lfs.com, once dowlonad and install the Git command line extension, set up Git LFS for your user account by running\ngit lfs install  #(only need to do this the first time)\nThen In each Git repository where you want to use Git LFS, select the file types you’d like Git LFS to manage (or directly edit your .gitattributes). You can configure additional file extensions at any time.\ngit lfs track \"path/to/file\"\nThen do the regular git add . and git -m \"message\" and git push. Note one must use git lfs track a file first before doing git add and git commit.\n\n\n\n\n\n\nNote\n\n\n\nNote you need to track the large-size file first before you add it to the staging area. But often you will find this error after you try to push your changes to the GitHub. In this case, you will have to remove the commit history of this file first. One way to do this is to reset –soft the HEAD to the previous working HEAD, and then do git lfs track followed by git add and git commit, git push. Specifically,\n\ngit reset --soft HEAD ~1  # or the_7-char_commit_hash\ngit lfs track \"path/to/large_file\"\ngit add .\ngit commit -m \"commit message\"\ngit push\nNote the --soft option allows the changes in the working directory not affected, otherwise any change after the previous commit will be removed.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#contribute-by-forking-a-github-repo-and-commit-to-the-forked-repo-and-create-a-pull-request-refer-to-the-best-workflow-belowsec-bestworkflow",
    "href": "git.html#contribute-by-forking-a-github-repo-and-commit-to-the-forked-repo-and-create-a-pull-request-refer-to-the-best-workflow-belowsec-bestworkflow",
    "title": "4  Use Git and GitHub",
    "section": "4.9 Contribute by forking a GitHub repo and commit to the forked repo and create a pull request (refer to [the best workflow below]Section 6.3 )",
    "text": "4.9 Contribute by forking a GitHub repo and commit to the forked repo and create a pull request (refer to [the best workflow below]Section 6.3 )\n\nafter forking a (foreign) GitHub repo to your own GitHub account, git clone that repo under your account to your local repo.\nmake changes in your local directory.\nSubmitting your changes for review\n\nCommit your changes locally. Once you are ready to submit your changes, run these commands in your terminal:\ngit add -A                            # Stages all changes, short for --all \ngit commit -m '[your commit message]' # Makes a git commit\nMake a pull request. (A pull request is a proposal to change) A GitHub pull request allows the owner of the forked upstream repo to review and make comments on your changes you proposed. Once approved, the upstream owner can merge your changes. Run:\ngit push origin # Push current branch to the same branch on GitHub\n\nThen go to your remote forked repo in your account on the GitHub site and click Contribute,and then Open pull request, this will take you to the upstream repo. In the form, leave a message explaining the change, and Create pull request. Do not select Close pull request unless you want to cancel the pull request.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#project",
    "href": "git.html#project",
    "title": "4  Use Git and GitHub",
    "section": "4.10 Project",
    "text": "4.10 Project\n\nFirst make sure you have forked the course repo https://github.com/ywanglab/stat1010.git\nto your own GitHub account.\nNow go to your GitHub account, git clone the forked course repo\n\ngit clone https://github.com/your_git_user_name/stat1010.git\nto your local computer\n\nadd your resume file in the folder ./resume\n\ngit add, commit and push your changes to the upstream repo using\ngit add .\n\ngit commit -m \"added YourFirstName's resume\"\n\ngit push origin\n\nThen go to your remote forked repo in your account on the GitHub site and click Contribute,and then Open pull request, this will take you to the upstream repo. In the form, leave a message explaining the change, and Create pull request. Do not select Close pull request unless you want to cancel the pull request.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#more-on-git",
    "href": "git.html#more-on-git",
    "title": "4  Use Git and GitHub",
    "section": "4.11 More on git",
    "text": "4.11 More on git\ngit pull = git fetch + git merge\n\ngit fetch → downloads commits from the remote into your local refs (e.g. origin/main).\ngit merge → merges those new commits into your current branch.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#git-pull-what-does---ff-mean",
    "href": "git.html#git-pull-what-does---ff-mean",
    "title": "4  Use Git and GitHub",
    "section": "4.12 Git pull: What does --ff mean?",
    "text": "4.12 Git pull: What does --ff mean?\n\n--ff = fast-forward if possible.\nThat means: if your branch has no local commits since it last matched the remote, Git will simply move the branch pointer forward to match the remote — no merge commit is created.\n\nExample (before pull):\nA---B---C  (origin/main)\n     \nA---B   (main)\nIf you run git pull --ff and your branch is strictly behind origin/main, Git just slides main forward:\nA---B---C   (origin/main, main)\n\ngit pull without flags:\n\nMay create a merge commit if histories diverged.\n\ngit pull --ff:\n\nDoes a fast-forward if possible.\nIf not possible (you made local commits), Git falls back to a merge commit.\n\ngit pull --ff-only:\n\nDoes a fast-forward only.\nIf not possible, it aborts with an error (no merge commit allowed).\n\n--ff is safe if you don’t mind merge commits being created when necessary.\n--ff-only is stricter (no merge bubbles, linear history).\nTeams often configure one of these globally so git pull always behaves consistently.\n\nwhen there is a diverge\n\n--ff-only → aborts with an error.\n--ff → falls back to a merge, creating a merge commit (see next section).\n\n\n4.12.1 git pull or git pull --ff (merge fallback)\n\nGit fetches origin/main at C\nGit merges C into your local main with D, producing M:\n\nAfter pull (local):\nA──B──C\n     \\ \\\n      D─M    (main)\n        ^\n     merge commit\nWhen you run git merge origin/main (or git pull with merge strategy):\n\nGit identifies the common ancestor of the two branches → here, commit B.\nThen it looks at:\n\nThe changes between B → C (remote’s changes).\nThe changes between B → D (your changes).\n\nGit tries to combine both sets of changes into a new snapshot.\n\nThat new snapshot becomes a new commit M. The merge commit M exists only locally until you git push. * When you push, origin/main is updated to point to M, and the remote history now includes that merge commit.\n\nPros: Preserves exact history as it happened (no rewrite).\nCons: Adds merge commits; history can get “braided”.\n\n\n\n4.12.2 Option 2: git pull --rebase (replay your work on top of remote)\n\nGit rewrites your local commits onto the fetched remote tip:\n\nRewrites D into D' applied after C.\n\n\nA──B──C──D'     (main)\n        ^\n      rebased (new) commit\n\nPros: Linear history, no merge commit.\nCons: Rewrites your local commits (new SHAs). If you had already pushed D, you’ll need git push --force-with-lease, see below.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#how-to-set-opitons-gloabally",
    "href": "git.html#how-to-set-opitons-gloabally",
    "title": "4  Use Git and GitHub",
    "section": "4.13 How to set opitons gloabally",
    "text": "4.13 How to set opitons gloabally\n\nTeam prefers linear history → git pull --rebase (and set it as default)\ngit config --global pull.rebase true\ngit config --global rebase.autoStash true\nKeep exact history / avoid rewrite → git pull --ff (merge when needed)\ngit config --global pull.rebase false\nNever auto-merge; be explicit → git pull --ff-only\ngit config --global pull.ff only",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#rebuild-the-index-respecting-.gitignore",
    "href": "git.html#rebuild-the-index-respecting-.gitignore",
    "title": "4  Use Git and GitHub",
    "section": "6.1 Rebuild the index respecting .gitignore",
    "text": "6.1 Rebuild the index respecting .gitignore\nIf you have modified .gitignore and you already pushed some files that you did not want to push, to remove those files already pushed to Github, you need to remove them from the git index to untrack them.\ngit rm -r --cached .  #redo all the index\ngit add .\ngit commit -m \"Reindex: drop ignored files from repo\"\ngit push origin &lt;your-branch&gt;\nto remove specific folder or files:\ngit rm -r --cached .Rhistory .Rproj.user # `-r` is needed for a directory",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#unstage-and-untrack",
    "href": "git.html#unstage-and-untrack",
    "title": "4  Use Git and GitHub",
    "section": "6.2 Unstage and untrack",
    "text": "6.2 Unstage and untrack\n\nunstage = remove from the staging area (index), but keep the file under Git’s tracking.\nuntrack = stop Git from tracking the file altogether.\n\n\n6.2.1 To unstage (but keep tracking):\nIf you already ran git add file.txt and want to undo that:\ngit reset HEAD file.txt\nNow file.txt is back in “modified” state but not staged. To unstage everything:\ngit reset HEAD\n\n\n6.2.2 To unstage:\nIf a file is already committed to the repo but you want Git to forget it:\ngit rm --cached file.txt\n\n--cached removes it from the index (tracking) but leaves it in your working directory.\nNext commit will record the removal.\nIf you want to untrack entire directories:\n\ngit rm -r --cached my_folder/\n\n\n6.2.3 Prevent tracking in the future\nAdd the file or folder to .gitignore so Git won’t pick it up again:\n# .gitignore\nfile.txt\nmy_folder/",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#sec-bestworkflow",
    "href": "git.html#sec-bestworkflow",
    "title": "4  Use Git and GitHub",
    "section": "6.3 Best workflow with GitHub from Colab (or a local device)",
    "text": "6.3 Best workflow with GitHub from Colab (or a local device)\nPre-req: Local repo is a clone of the GitHub repo with aligned HEAD\n\nKeep sync with the upstream original owner repo. On GitHub, in the forked repo (under your account), Click on “Sync fork”.\nOpen (or create) a notebook from G-drive to work with in Colab.\nThen, mount the G-drive. If on a local device, use the same workflow (open or create a notebook from the project directory).\nIn a termnal of Colab (or a terminal in VSC in a local device)\n\n\ngit pull or git pull --ff or (safer method: git pull --ff-only)\n\nIf permission denied on G-drive, run this first then repeat git pull.\nchmod +x .git/hooks/*\n\nAfter editing, and before finish\n\ngit status\ngit add  files-to-commit\ngit commit -m \"commit message\"\ngit push  # this will push the files-to-commit to your fork/main",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#team-github-workflow",
    "href": "git.html#team-github-workflow",
    "title": "4  Use Git and GitHub",
    "section": "6.4 Team Github workflow",
    "text": "6.4 Team Github workflow",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#initial-setup",
    "href": "git.html#initial-setup",
    "title": "4  Use Git and GitHub",
    "section": "6.5 Initial setup",
    "text": "6.5 Initial setup\n\nFork and Clone\n\n\nFork: You click “Fork” on GitHub → it creates a copy of the repo under your GitHub account. Navigate to https://github.com/ywanglab/STAT4160, then click on “Fork”.\nClone: You download a local copy of your fork to your computer. (only do this for the first time)\n\nSo after forking, you typically do (only for the first time)\ngit clone https://github.com/YOUR-USERNAME/REPO-NAME.git #REPO-NAME should be STAT4160\ncd REPO-NAME   # the REPO-NAME should be STAT4160, cd to the current working directory  \n\nAdd the original repo as “upstream”\n\nYour fork is linked to your GitHub account (the “origin”). To stay in sync with the original project, add a remote for the source repository:\ngit remote add upstream https://github.com/ywanglab/STAT4160\nCheck remotes:\ngit remote -v\n# origin    https://github.com/YOUR-USERNAME/REPO-NAME.git (push/pull)\n# upstream  https://github.com/ORIGINAL-OWNER/REPO-NAME.git (pull only)\n\nCreate a feature branch in your fork\n\nNever work directly on main. Instead create a new branch:\ngit checkout -b feature/my-contribution  # eg: homework/your_initial\n# edit files...\n\n# after you done your edit, push changes to origin/main\n\ngit add files-to-commit  # git add filename (or directoryname) use `.` rarely as it will add all files in the git directory. \ngit commit -m \"Fix bug in utils\"\ngit push -u origin feature/my-contribution  #git push by default push changes to origin/main\n\nOpen a Pull Request (PR) (only do this for the contribution you want to make, such as homework)\nGo to your fork on GitHub (https://github.com/YOUR-USERNAME/REPO-NAME).\nGitHub will show a banner: “You recently pushed to feature/my-contribution. Do you want to open a Pull Request?”\nClick it → select base repository = (upstream) original owner repo, compare = your branch.\n\nNote: head repository → your fork (e.g. YOUR-USERNAME/REPO-NAME) and branch (feature/…) that contains your changes.\n\nWrite a good description and submit the PR.\n\nNow the maintainers of the original repo will review it. If approved, they’ll merge it.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#keep-your-fork-in-sync",
    "href": "git.html#keep-your-fork-in-sync",
    "title": "4  Use Git and GitHub",
    "section": "6.6 Keep your fork in sync",
    "text": "6.6 Keep your fork in sync\nBefore making new contributions, update your fork/main with the latest main from upstream:\nOption A) Do it on GitHub: If GitHub shows something like “This branch is 1 commit behind”, “Sync Fork”.\nOption B): do it via terminal:\ngit checkout main   # checkout main\ngit pull upstream main        # pull from the upstream original repo\ngit push origin main          # update your fork on GitHub\nThen branch off main again for your next feature.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#git-faq",
    "href": "git.html#git-faq",
    "title": "4  Use Git and GitHub",
    "section": "6.7 Git FAQ",
    "text": "6.7 Git FAQ\n\nExplain staging area, working area, working directory\n\n\nWorking directory / working tree (aka “working area”): The files on your disk you edit.\nStaging area (index): The “snapshot-in-progress” you will commit next. You move changes here with git add.\nLocal repository (.git): The database of commits/objects/refs. git commit writes a new commit to this store.\nHEAD: A pointer to your current commit/branch.\n\n\n6.7.1 Working directory (working tree) vs “actual files on disk”? Save vs commit? What are “index” and “working tree”?\n\nWorking directory/working files / working tree: the files on your disk under the repo. This is the “actual files on disk” for the project (both tracked and untracked). What git status calls “Changes not staged for commit” (for tracked edits) and “Untracked files”.\nIndex (staging area): a binary file at .git/index that holds the exact snapshot you will commit next. You put changes into the index with git add. Git status calls “Changes to be cmmitted”.\n\nCompare the layers\ngit status                       # see working tree vs index vs HEAD\ngit diff                         # working tree vs index: what you edited but haven't staged. \ngit diff --staged                # index vs HEAD: what's staged vs. last commit\ngit log --oneline --graph --decorate --all   # visualize history (merge vs rebase)\nFlow:\n(edit & save) → working tree\ngit add → index\ngit commit → new commit from the index\n\nLocal repository: all Git objects in .git/ (commits, trees, blobs, refs).\n\nSave vs commit\n\nSave: editor/OS action that writes a file to disk (affects working tree only).\nCommit: Git action that records a snapshot of the index into the repository history (.git/objects) with a message and metadata.\n\n\n\n\n6.7.2 1) After git add, how to undo (un‑add) a file or directory?\nUnstage (but keep your edits in the working tree):\n# Preferred (Git 2.23+)\ngit restore --staged &lt;file-or-dir&gt;\n\n# Older (still works)\ngit reset HEAD &lt;file-or-dir&gt;\n\n# Unstage everything that’s currently staged\ngit restore --staged .\n# or\ngit reset  #eqiv to: git reset --mixed HEAD: reset the index to match the current HEAD (unstaging changes) but does not move HEAD\nPartially unstage hunks:\ngit restore --staged -p &lt;file&gt;   # or: git reset -p &lt;file&gt;\nIf you accidentally started tracking something (e.g., should be ignored), remove it from the index only:\ngit rm --cached -r &lt;path&gt;   # leaves the file(s) on disk, stops tracking\n\n\n6.7.3 2) After git commit, how to un‑commit?\nUndo the last commit locally (choose how much to keep):\ngit reset --soft HEAD~1   # keep changes staged\ngit reset --mixed HEAD~1  # keep changes in working tree (unstaged) [default]\ngit reset --hard HEAD~1   # discard the commit AND your local changes (danger!)\nIf the commit is already pushed (others may have pulled it), prefer:\ngit revert &lt;commit-sha&gt;   # makes a new commit that undoes the old one\nFix or edit the most recent commit without changing its parent:\ngit commit --amend\ngit commit --amend (more)\nRewrites the last commit.\n\nFix message only:\ngit commit --amend -m \"Better message\"\nAdd forgotten changes (stage them first):\ngit add &lt;files&gt;\ngit commit --amend --no-edit   # keep prior message\nChange author/committer timestamp:\ngit commit --amend --no-edit --reset-author\n\nResults in a new commit SHA. If the old commit was pushed, you’ll need:\ngit push --force-with-lease\nIf you must rewrite published history (e.g., after a local rebase), push safely:\ngit push --force-with-lease\n\n\n\n6.7.4 3) When git push, what conflicts can occur? How to fix them?\nA “push conflict” is usually a non‑fast‑forward rejection because the remote has new commits you don’t have.\nSymptom: rejected] ... (fetch first) or non-fast-forward.\nFix:\ngit fetch origin\n# Option A: merge\ngit merge origin/&lt;branch&gt;\n\n# Option B: rebase (keeps history linear)\ngit rebase origin/&lt;branch&gt;\n\n# After Having Resolved any conflicts, then:\ngit push\n\n\n\n6.7.5 4) When git pull, what conflicts can occur, and how to fix them?\ngit pull = fetch + merge (by default) or fetch + rebase (with --rebase). Conflicts occur when both sides changed the same lines or one side edits a file the other deleted.\nMerge flow (default pull):\ngit pull\n# If conflicts:\ngit status\n# open files, resolve &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers\ngit add &lt;resolved-file&gt;...\ngit commit           # completes the merge\nRebase flow (git pull --rebase):\ngit pull --rebase\n# If conflicts:\ngit status\n# resolve, then:\ngit add &lt;resolved-file&gt;...\ngit rebase --continue\n# or:\ngit rebase --abort    # to go back to the state right before rebase\nRelated:\n\ngit rebase --continue → after resolving a conflict, proceed to the next commit.\ngit rebase --skip → drop the problematic commit and continue.\ngit rebase --quit → stop the rebase without resetting your current files/HEAD; it just removes rebase state (rarely needed—--abort is the safe “put it back” button).\n\nHelpful:\ngit mergetool         # launch a diff/merge tool if configured\n\n\n6.7.6 5) Why create a new branch instead of working on main?\n\nKeep main clean, stable, and deployable.\nIsolate work so you can open focused pull requests and get review.\nParallel development without stepping on each other.\nSafer experiments; easy to abandon a branch if it doesn’t pan out.\nRelease/hotfix workflows (e.g., release/*, hotfix/*).\nCI/policy gates per branch.\n\n\n\n\n6.7.7 6) How git stash works and why we need it\ngit stash saves your uncommitted changes (working tree and staged) into a stack entry, then reverts your tree to a clean state—handy when you must switch branches or pull/rebase but aren’t ready to commit.\nCommon commands:\ngit stash push -m \"wip: message\"    # save staged + unstaged\ngit stash push -u                    # include untracked files\ngit stash push -a                    # include ignored files\ngit stash list\ngit stash show -p stash@{0}          # see what’s inside\ngit stash apply stash@{0}            # apply, keep it on the stack\ngit stash pop stash@{0}              # apply and remove from the stack\ngit stash drop stash@{0}\n# Partial / path-specific:\ngit stash -p                         # interactively stash hunks\ngit stash push -- &lt;path1&gt; &lt;path2&gt;    # stash only these paths\n\n\n\n6.7.8 8) Difference between git reset and git revert\n\ngit reset: Moves a branch/HEAD to another commit (optionally touching index and working tree). It rewrites history for that branch.\n\n--soft: move HEAD only (keep index + working tree)\n--mixed (default): move HEAD + reset index (keep working tree)\n--hard: move HEAD + reset index + working tree (discard changes)\nUse for local surgery (e.g., uncommit/squash) before sharing.\n\ngit revert: Creates a new commit that undoes the changes from a prior commit. Does not rewrite history; safe on shared branches.\n\nRule of thumb: Use revert for public history, reset for local/private history.\n\n\n\n6.7.9 9) How to remove files that are already pushed? Explain git rm --cached\nIf you only want Git to stop tracking the file(s) but keep them on disk:\ngit rm --cached -r &lt;path&gt;\necho \"&lt;path&gt;/\" &gt;&gt; .gitignore\ngit commit -m \"Stop tracking &lt;path&gt;\"\ngit push\n\ngit rm --cached removes from the index (stops tracking) but does not delete your local copy.\n\nIf sensitive/big files are already in history and must be purged:\n\nUse git filter-repo (recommended) or BFG:\n\n# after installing git-filter-repo\ngit filter-repo --path &lt;path&gt; --invert-paths\ngit push --force-with-lease --all\ngit push --force-with-lease --tags\n\nRotate any exposed secrets and tell collaborators to re-clone or hard‑reset to the new history.\n\n\n\n\n6.7.10 10) Difference between git pull --rebase and git pull -ff\n\ngit pull --rebase: Fetch, then reapply your local commits on top of the updated upstream. This rewrites your local commits for a cleaner, linear history. Configure permanently:\ngit config --global pull.rebase true     # always rebase on pull\n# or for one repo:\ngit config pull.rebase true\n\n-f is a short flag for fetch –force, so -ff is basically “fetch with force (twice)””.\n\nIf you don’t use --rebase, then git pull merges by default.--ff-only keeps history clean by aborting instead of making a merge commit when a fast‑forward isn’t possible.\n\n\n\n\n6.7.11 11) Explain git rebase\nRebase “moves” your commits to a new base commit.\nExample: keep a feature branch up to date without merge commits:\ngit checkout feature\ngit fetch origin\ngit rebase origin/main   # replay feature’s commits on top of latest main\n# resolve conflicts per-commit:\ngit add &lt;resolved-file&gt;...\ngit rebase --continue\n# when done and if previously pushed:\ngit push --force-with-lease\nInteractive rebase to clean history (reorder/squash/edit/drop):\ngit rebase -i HEAD~5\n# pick | reword | squash | fixup | edit | drop\n# tip: use autosquash:\ngit commit --fixup &lt;sha&gt;\ngit rebase -i --autosquash origin/main\nAdvanced: move a range of commits to a different base:\ngit rebase --onto &lt;new-base&gt; &lt;old-base&gt; &lt;branch&gt;\nGuidelines\n\nDon’t rebase commits others are already depending on (unless your team agrees and you use --force-with-lease).\nTest after rebases; conflicts are resolved commit‑by‑commit.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#difference-between-git-rebase-and-git-merge",
    "href": "git.html#difference-between-git-rebase-and-git-merge",
    "title": "4  Use Git and GitHub",
    "section": "6.8 4) Difference between git rebase and git merge",
    "text": "6.8 4) Difference between git rebase and git merge\nGoal (both): bring changes from one line of history into another.\n\n6.8.1 Merge\n\nCreates a merge commit that has two parents; preserves true history.\nDoesn’t rewrite existing commits.\nSafer on shared branches; good for “what actually happened.”\n\n# Before\nmain:    A---B---C\n             \\\nfeature:       D---E\n\n# Merge feature -&gt; main\nmain:    A---B---C---M\n                 /   \\\nfeature:        D-----E\n\n\n6.8.2 Rebase\n\nRewrites your commits to appear on top of a new base (new SHAs).\nProduces a linear history (no merge commit).\nAvoid rebasing commits others already pulled (or force-push with care).\n\n# Rebase feature onto latest main\nmain:    A---B---C\n                 \\\nfeature:          D'--E'    (D and E replayed; new SHAs)\nRule of thumb: merge for public/shared history; rebase to keep your feature branch tidy before sharing.\n\n\n6.8.3 On which branch do merge and rebase happen?\n\ngit merge other-branch merges other-branch into the branch you currently have checked out (the “current branch”). If you want to merge into some target branch, you must first switch to it:\ngit switch target\ngit merge other\ngit rebase &lt;upstream&gt; rewrites the current branch so its commits replay on top of &lt;upstream&gt;:\ngit switch feature\ngit rebase origin/main\nAdvanced: you can rebase a branch without checking it out:\ngit rebase origin/main feature   # rewrites 'feature'\nBut conceptually, rebase always moves one branch’s commits onto a new base.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#quick-reference-handy-snippets",
    "href": "git.html#quick-reference-handy-snippets",
    "title": "4  Use Git and GitHub",
    "section": "6.9 Quick reference (handy snippets)",
    "text": "6.9 Quick reference (handy snippets)\n# Unstage everything\ngit restore --staged .\n\n# Uncommit but keep edits\ngit reset --mixed HEAD~1\n\n# Undo a pushed commit safely\ngit revert &lt;sha&gt;\n\n# Resolve pull with rebase and conflicts\ngit pull --rebase\n# ...resolve...\ngit rebase --continue\n\n# Stop tracking a file/folder (keep it locally)\ngit rm --cached -r &lt;path&gt; && echo \"&lt;path&gt;/\" &gt;&gt; .gitignore\n\n# Fast‑forward only pull (abort if divergence)\ngit pull --ff-only",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#index-vs.-working-files-aka-working-tree",
    "href": "git.html#index-vs.-working-files-aka-working-tree",
    "title": "4  Use Git and GitHub",
    "section": "6.10 1) Index vs. working files (aka working tree)",
    "text": "6.10 1) Index vs. working files (aka working tree)\nWorking files / working tree\n\nThe actual files on disk that you edit and save in your editor.\nCan include both tracked and untracked files.\nWhat git status calls “Changes not staged for commit” (for tracked edits) and “Untracked files”.\n\nIndex / staging area\n\nA snapshot Git keeps (in .git/index) of exactly what will be committed next.\nYou put changes into the index with git add.\nWhat git status calls “Changes to be committed”.\n\nCompare the layers\ngit diff             # working tree  vs index   (what you edited but haven't staged)\ngit diff --staged    # index         vs HEAD    (what's staged vs last commit)\nFlow:\n(edit & save) → working tree\ngit add → index\ngit commit → new commit from the index",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#i-saved-a-file-on-one-branch-then-checked-out-a-new-branch-and-edited-it-again.-what-version-do-i-have-on-disk",
    "href": "git.html#i-saved-a-file-on-one-branch-then-checked-out-a-new-branch-and-edited-it-again.-what-version-do-i-have-on-disk",
    "title": "4  Use Git and GitHub",
    "section": "6.11 3) “I saved a file on one branch, then checked out a new branch and edited it again. What version do I have on disk?”",
    "text": "6.11 3) “I saved a file on one branch, then checked out a new branch and edited it again. What version do I have on disk?”\nIt depends on whether your first edits were committed and whether switching branches would overwrite those edits.\n\n6.11.1 Cases\n\nYou did NOT commit, and the switch would overwrite your changes Git blocks the switch:\nerror: Your local changes to the following files would be overwritten by checkout:\n  path/to/file\nFix: commit, stash, or discard those changes first.\nYou did NOT commit, and the switch does NOT overwrite your changes Git allows the switch and carries your uncommitted edits into the new branch. On disk you see your latest saved content (not the branch’s clean version). The changes now show as “modified” on the new branch. If you commit now, the commit lands on the new branch.\nYou DID commit on the first branch When you switch, Git rewrites your working tree to match the target branch’s snapshot. You’ll see the target branch’s version of the file on disk.\nUntracked files Untracked files follow you across branches. If an untracked path would conflict with a tracked file in the target branch, Git blocks the switch unless you stash with -u or clean with git clean -fd (dangerous).\n\n\n\n6.11.2 Tips\n\nTo keep branch changes separate, either commit/stash before switching or use separate work trees:\ngit worktree add ../repo-main main\ngit worktree add ../repo-feature feature\nTo forcibly see a file as it exists on another branch (without switching):\ngit show other-branch:path/to/file &gt; path/to/file   # overwrites file on disk\n# or, with restore (safer semantics):\ngit restore --source other-branch -- path/to/file",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#suggested-team-workflow-you-maintain-main-teammates-contribute",
    "href": "git.html#suggested-team-workflow-you-maintain-main-teammates-contribute",
    "title": "4  Use Git and GitHub",
    "section": "6.12 4) Suggested team workflow (you maintain main, teammates contribute)",
    "text": "6.12 4) Suggested team workflow (you maintain main, teammates contribute)\nBelow is a light‑weight, reliable feature‑branch + PR flow (GitHub/GitLab/Bitbucket compatible).\n\n6.12.1 Repository / policy (one‑time setup)\n\nProtect main: disallow direct pushes, require PRs, require at least 1 review, require CI to pass, and (optionally) Require linear history.\nPrefer “Squash and merge” or “Rebase and merge” on PRs to keep main tidy.\nAdd CODEOWNERS (optional) so certain paths require your review.\nEncourage small, focused PRs.\n\n\n\n6.12.2 Personal Git config (everyone)\ngit config --global pull.rebase true     # rebase on pull; cleaner history\ngit config --global fetch.prune true     # remove deleted remote branches on fetch\ngit config --global rerere.enabled true  # remember conflict resolutions (handy)\n\n\n6.12.3 Contributor workflow (feature branch)\n# 1) Sync and branch off up-to-date main\ngit switch main\ngit fetch origin\ngit pull --ff-only       # keep local main as a clean fast-forward\ngit switch -c feature/short-desc\n\n# 2) Develop\n# ...edit, test, commit in small logical chunks...\ngit add -p\ngit commit -m \"feat: short message\"\n\n# 3) Keep branch current (periodically)\ngit fetch origin\ngit rebase origin/main   # replay your commits on latest main\n# resolve conflicts → git add ... → git rebase --continue\n\n# 4) Publish and open PR\ngit push -u origin feature/short-desc\n# (Open PR, link issue, ensure CI passes, request review)\n\n# 5) Address review\n# Use fixup commits for clean history:\ngit commit --fixup &lt;sha-to-fix&gt;\ngit rebase -i --autosquash origin/main\ngit push --force-with-lease\n\n\n6.12.4 Maintainer (you) merging PRs\n\nEnsure tests pass, reviews done.\nChoose Squash & Merge (one clean commit on main) or Rebase & Merge (preserve individual commits but linear).\nAfter merge:\n# Keep your local main clean and current\ngit switch main\ngit pull --ff-only\nOptionally tag releases:\ngit tag -a v1.2.3 -m \"Release 1.2.3\"\ngit push origin v1.2.3\n\n\n\n6.12.5 Hotfixes\n\nBranch from main: git switch -c hotfix/issue-123\nPatch, test, PR, merge → tag a patch release.\n\n\n\n6.12.6 Common “gotchas” and fixes\n\nPush rejected (non‑fast‑forward): git fetch origin && git rebase origin/main (then resolve & push).\nRebased your feature and need to update PR: git push --force-with-lease.\nCan’t switch branches due to local edits: commit, git stash (use -u to include untracked), or discard.\n\n\n\n\n6.12.7 Quick reference of commands mentioned\n# See differences between layers\ngit status\ngit diff\ngit diff --staged\n\n# Stage/unstage in parts (hunks)\ngit add -p\ngit restore --staged -p &lt;file&gt;\n\n# Stash changes\ngit stash push -m \"wip\"        # tracked files\ngit stash push -u -m \"wip\"     # include untracked\ngit stash list\ngit stash show -p stash@{0}\ngit stash pop                  # apply & drop top entry\n\n# Safe push after history rewrite\ngit push --force-with-lease",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#how-to-fix-conflict-when-switching-branches",
    "href": "git.html#how-to-fix-conflict-when-switching-branches",
    "title": "4  Use Git and GitHub",
    "section": "6.13 How to fix conflict when switching branches",
    "text": "6.13 How to fix conflict when switching branches\nConflicts occurs when two branches have different versions (commit HEADs) of a file, and you then edit one version of that file on one branch without commiting it, and then you try to switch to another branch. Git will block you switching. When both branches point to the same version, then no conflicts arises and the change in one branch follow you to a new branch.\nConflicts typically occrurs when 1) same hunk edited differnetly in both branches (overlapping lines). Git typically will merge differnces of two different lines. 2) delete/modfify: one side deleted a file, the other edited it. 3) rename/rename to diffent names.\nFix options: * Keep your WIP for later\ngit stash push -m \"WIP\" # Git saves the changes on the branch where you made changes (but not committed) on top of whatever commit your HEAD currently points to. \ngit checkout main #switch to a different branch \ngit stash pop  # apply the changes and delete the stash on main. You can do this on any branch. git stash is like a clipboard, it is global to the entire repo. \n\nor commit your WIP on the current branch (where you made the change), then switch\n\ngit add -A\ngit commit -m \"WIP\"\ngit checkout main #switch\n\n\nor discard WIP (dangerous), put files back to the last commit\n\ngit restore notes.txt # perform on the branch where you made the change. \ngit checkout main\n\nRule of thumb\nStash: Do it on the branch where your changes currently live, but you can apply later anywhere.\nRestore: Do it on the branch where you want to discard/reset changes (usually the branch you’re already on).\n\n6.13.0.1 When Git cannot auto-merge, how to resolve a conflict\nOpen the file → delete conflict markers → keep desired content-&gt;Save\ngit add  to mark resolved.\ngit commit or git stash drop (mark it resolved witout commit, and drop the stash if no longer need it)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#when-conflict-occurs-using-git-pull-and-how-to-resolve-it",
    "href": "git.html#when-conflict-occurs-using-git-pull-and-how-to-resolve-it",
    "title": "4  Use Git and GitHub",
    "section": "6.14 When conflict occurs using git pull and how to resolve it",
    "text": "6.14 When conflict occurs using git pull and how to resolve it\nThis is when remote repo and local repo diverges. (remote repo and local repo share a common ancetor, but each has new commits. ) If a conflict occurs, git pull will not make a merge commit but will merge all files without conflicts.\nIf using Merge flow\ngit pull # (fetch+merge: fetch updating the index of origin/main, always successful. merge all non-conflict files)\n# if conflicts:\n# 1) edit files to remove &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt; markers\ngit add &lt;files&gt;\ngit commit        # completes the merge commit\n# or bail out:\ngit merge --abort # moving back to where it was before git merge (the updated remote index kept)\n\nIf using Rebase flow:\ngit pull --rebase\n# if conflicts:\n# 1) fix files\ngit add &lt;files&gt;\ngit rebase --continue\n\ngit push --force-with-lease # only needed if your rebase rewrote history(commits) already on remote \n# or bail out:\ngit rebase --abort\n\nIf Parking your work\ngit stash -u      # include untracked. -a (aka --all) including ignored. \n# ... switch branches / pull ...\ngit stash pop     # reapply; resolve if conflicts",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#conflicts-occur-when-git-push-and-how-to-resolve",
    "href": "git.html#conflicts-occur-when-git-push-and-how-to-resolve",
    "title": "4  Use Git and GitHub",
    "section": "6.15 Conflicts occur when git push and how to resolve",
    "text": "6.15 Conflicts occur when git push and how to resolve\nThe conflicts may occur due to several situations:\n\nNon-fast-forward push (someone pushed before you) Fix A: Merge approach (simple)\n\ngit pull             # resolve conflicts if prompted\ngit push\n\nFix B: rebase apprach (cleaner history)\ngit fetch\ngit rebase origin/main\n# if conflicts: edit files → git add &lt;files&gt; → git rebase --continue (repeat)\ngit push\n\n\nPush rejected after you rewrote history (by amend/rebase) What is rewriting history? an operation changes the existing commit ID (SHA)\n\n\ngit commit –amend\ngit rebase\ngit reset –hard  followed by further commits.\nHistory-editing toosl (git filter-repo, etc)\n\nA typical way to use git commit –amend are: 1. add a missing file\ngit add missing.file\ngit commit --amend --no-edit\n\nedit commit message\n\ngit commit --amend -m \"new message\"\n# You amend or rebase (history changes)\ngit commit --amend --no-edit  #--no-edit: keep the same commit history\ngit push\n# ! [rejected] (non-fast-forward)\n\nThen\ngit push --force-with-lease\n\n\nNo upsteam branch\n\ngit push -u origin feature/api #simply use -u to create the new branch\n\n\nrejectd because the branch is a protected branch. Create PR.\n\n\nlargile/file type blocked (server or hooks) Fix: Use Git LFS:\n\ngit lfs install\ngit lfs track \"*.mp4\"\ngit add .gitattributes bigvideo.mp4\ngit git commit -m \"Track with LFS\"\ngit push",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git.html#git-merge-a-branch",
    "href": "git.html#git-merge-a-branch",
    "title": "4  Use Git and GitHub",
    "section": "6.16 Git merge a branch",
    "text": "6.16 Git merge a branch\n\nWhole branch → git merge feature-x\nOne commit → git cherry-pick \nOne file/dir → git restore –source feature-x – \nSingle-commit result → git merge –squash feature-x # only contents from feature-x, no merge commit history.\n\nIn-merge resolution → –ours/–theirs (per-file) or -X ours/theirs (strategy)\n# keep your current branch’s version for that file\ngit checkout --ours  path/to/file\n\n# keep the merging branch’s version for that file\ngit checkout --theirs path/to/file\n\ngit add path/to/file\n\n# prefer current branch on conflicts\ngit merge -X ours feature-x\n\n# prefer the other branch on conflicts\ngit merge -X theirs feature-x",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Use Git and GitHub</span>"
    ]
  },
  {
    "objectID": "0_markdown.html",
    "href": "0_markdown.html",
    "title": "5  My Jupyter Notebook",
    "section": "",
    "text": "Yi Wang (boldfaced using ** **)\nEducator AUM\nThe following line is italicized using * *\nI am interest in data science because it is a discipline that I feel love with.\n\n5.0.1 Perform addtion\n\n# code block\n1+1\n\n2\n\n\n\n\n5.0.2 Horizontal Rule\nThree or more\nfirst rule using ***\n\nusing dashes —\n\nUsing (underscores) ___\n\n\n\n5.0.3 Bulet list\nusing *\n\nBird\nFrog\nCat\nDog\n\n\n\n5.0.4 Numbered list\nusing 1. item (there is a space between 1. and item)\n\nApple\nPear\nPeach\n\n\n\n5.0.5 Tables\n\n\n\nleft-aligned\ncentered\nright-aligned\n\n\n\n\n1/2/2020\nMary\nApple\n\n\n1/3\nJohnason\nTomato\n\n\n\n\n\n5.0.6 Hyperlinks\nClick here to access my github account.\n\n\n5.0.7 Images\n\n\n\nA computer monitor\n\n\n\n\n5.0.8 Code/Syntax highlighting\ns = \"Python syntax highlighting\"\nprint s\n\n\n5.0.9 Blocked quotes\nusing &gt;\n\nBlockquotes are very handy in email to emulate reply text.\n\n\nThis line is part of the same quote.\n\n\n\n5.0.10 Strikethrough\nusing ~~ before and after a phrase\nstrikethrough this",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>My Jupyter Notebook</span>"
    ]
  },
  {
    "objectID": "assignment.html",
    "href": "assignment.html",
    "title": "6  Homework Assignments",
    "section": "",
    "text": "I will use some assignments from https://cognitiveclass.ai.\n\nBrowser Course & Projects. Search for Python for Data Science. Enroll Now the class, and Go to the Course, and Start the Course.\nComplete the following assignments from Modules 1-4 and Part of Module 5. Excluding the API section in Module 5.\n\n\n\n\n\n\n\n\nModule\nContents\nSuggested Deadlines\n\n\n\n\nModule 1\nPython Basics\n10/09/2023\n\n\nModule 2\nPython Data Structures\n10/09/2023\n\n\nModule 3\nPython Prrogramming Fundamentals\n10/09/2023\n\n\nModule 4\nWorking with Data in Python\n10/16/2023\n\n\nModule 5\nWorking with Numpy Arrays (Excluding Simple APIs)\n10/16/2023\n\n\nFinal Exam\nOptional\n\n\n\n\nComplete all Practice Questions, Review Questions and Labs. After your completing all the assignments, click on Progress, print the page (in PDF or hard copy), and send it to me. The page should show your username on the top right corner.\nEnroll in the course Data Anlaysis with Python.\nComplete the following assignments.\n\n\n\nModule\nContents\nSuggested Deadlines\n\n\n\n\nModule 1\nIntroduction\n10/23/2023\n\n\nModule 2\nData Wrangling\n10/30/2023\n\n\nModule 3\nExploratory Data Analysis\n11/06/2023\n\n\n\nEnroll in the course Data Visualization with Python.\nComplete the following assignments.\n\n\n\nModule\nContents\nSuggested Deadlines\n\n\n\n\nModule 1\nIntroduction to Visualization\n11/13/2023\n\n\nModule 2\nBasic Visualization Tools\n11/20/2023\n\n\nModule 3\nSpecialized Visualization Tools\n11/27/2023\n\n\nModule 4\nAdvanced Visualizaiton Tools (Optional)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Homework Assignments</span>"
    ]
  }
]